{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# DTSC 680: Applied Machine Learning\n",
    "# Name: Juliana Meirelles\n",
    "# Assignment 6: Mushroom Classifier"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Overview:\n",
    "\n",
    "The purpose of this assignment was to gain experience using KNN and PCA\n",
    "algorithms using the Mushroom Data set. This dataset is part of the UCI Machine Learning Repository. This data set includes many different features that categorize mushrooms by colors, shapes, etc. All of these features are used to classify mushrooms by either edible or poisonous. This is very helpful for people who enjoy mushroom hunting or foraging for mushrooms as many mushrooms are edible! Many mushrooms, though, are poisonous so mycologists have determined certain aspects that help to identify if a mushroom is edible or not.\n",
    "\n",
    "My process for this project:\n",
    "1. Import the Mushroom data set and view the data to understand what is going on.\n",
    "2. Use the KNN algorithm to impute missing values in the dataset. To do this, I will split the data into four subsets that will serve as training and testing data. This will be split according to data that is missing from one column in the data set. \n",
    "3. Train a RandomForestClassifier as well as a LogisticRegression model to predict whether a mushroom is edible or poisonous given this data set.\n",
    "4. Compute the accuracy, precision, and recall scores for a test set.\n",
    "5. Perform dimensionality reduction using PCA and keep 95% of the variance.\n",
    "6. Train two new models, a RandomForestClassifier and a LogisticRegression model, on this reduced dataset to predict whether a mushroom is edible or not.\n",
    "7. Compute the accuracy, precision, and recall scores for the model trained on the reduced data set using the same test set as before."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Preliminaries\n",
    "Importing Commonly used Packages"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Common imports\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib as mpl\n",
    "from matplotlib import cm\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "%matplotlib inline\n",
    "mpl.rc('axes', labelsize=14)\n",
    "mpl.rc('xtick', labelsize=12)\n",
    "mpl.rc('ytick', labelsize=12)\n",
    "import os"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Import the Data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Here, I am importing the Mushroom Data Set. Also I am renaming the columns because I have no idea what these one \n",
    "#letter columns mean and I need some reference points as to what features I'm working with.\n",
    "\n",
    "data = pd.read_csv(\"agaricus-lepiota.data\", names = ['class', 'cap-shape', 'cap-surface', 'cap-color', 'bruises', \n",
    "                                                       'odor', 'gill-attachment','gill-spacing', 'gill-size', \n",
    "                                                       'gill-color', 'stalk-shape', 'stalk-root',\n",
    "                                                       'stalk-surface-above-ring', 'stalk-surface-below-ring', \n",
    "                                                       'stalk-color-above-ring','stalk-color-below-ring', \n",
    "                                                       'veil-type', 'veil-color', 'ring-number', 'ring-type',\n",
    "                                                       'spore-print-color', 'population', 'habitat'])\n",
    "\n",
    "pd.set_option('display.max_columns', None)\n",
    "\n",
    "pd.set_option('display.max_rows', None)\n",
    "\n",
    "mushroom_df = pd.DataFrame(data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>class</th>\n",
       "      <th>cap-shape</th>\n",
       "      <th>cap-surface</th>\n",
       "      <th>cap-color</th>\n",
       "      <th>bruises</th>\n",
       "      <th>odor</th>\n",
       "      <th>gill-attachment</th>\n",
       "      <th>gill-spacing</th>\n",
       "      <th>gill-size</th>\n",
       "      <th>gill-color</th>\n",
       "      <th>stalk-shape</th>\n",
       "      <th>stalk-root</th>\n",
       "      <th>stalk-surface-above-ring</th>\n",
       "      <th>stalk-surface-below-ring</th>\n",
       "      <th>stalk-color-above-ring</th>\n",
       "      <th>stalk-color-below-ring</th>\n",
       "      <th>veil-type</th>\n",
       "      <th>veil-color</th>\n",
       "      <th>ring-number</th>\n",
       "      <th>ring-type</th>\n",
       "      <th>spore-print-color</th>\n",
       "      <th>population</th>\n",
       "      <th>habitat</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>p</td>\n",
       "      <td>x</td>\n",
       "      <td>s</td>\n",
       "      <td>n</td>\n",
       "      <td>t</td>\n",
       "      <td>p</td>\n",
       "      <td>f</td>\n",
       "      <td>c</td>\n",
       "      <td>n</td>\n",
       "      <td>k</td>\n",
       "      <td>e</td>\n",
       "      <td>e</td>\n",
       "      <td>s</td>\n",
       "      <td>s</td>\n",
       "      <td>w</td>\n",
       "      <td>w</td>\n",
       "      <td>p</td>\n",
       "      <td>w</td>\n",
       "      <td>o</td>\n",
       "      <td>p</td>\n",
       "      <td>k</td>\n",
       "      <td>s</td>\n",
       "      <td>u</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>e</td>\n",
       "      <td>x</td>\n",
       "      <td>s</td>\n",
       "      <td>y</td>\n",
       "      <td>t</td>\n",
       "      <td>a</td>\n",
       "      <td>f</td>\n",
       "      <td>c</td>\n",
       "      <td>b</td>\n",
       "      <td>k</td>\n",
       "      <td>e</td>\n",
       "      <td>c</td>\n",
       "      <td>s</td>\n",
       "      <td>s</td>\n",
       "      <td>w</td>\n",
       "      <td>w</td>\n",
       "      <td>p</td>\n",
       "      <td>w</td>\n",
       "      <td>o</td>\n",
       "      <td>p</td>\n",
       "      <td>n</td>\n",
       "      <td>n</td>\n",
       "      <td>g</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>e</td>\n",
       "      <td>b</td>\n",
       "      <td>s</td>\n",
       "      <td>w</td>\n",
       "      <td>t</td>\n",
       "      <td>l</td>\n",
       "      <td>f</td>\n",
       "      <td>c</td>\n",
       "      <td>b</td>\n",
       "      <td>n</td>\n",
       "      <td>e</td>\n",
       "      <td>c</td>\n",
       "      <td>s</td>\n",
       "      <td>s</td>\n",
       "      <td>w</td>\n",
       "      <td>w</td>\n",
       "      <td>p</td>\n",
       "      <td>w</td>\n",
       "      <td>o</td>\n",
       "      <td>p</td>\n",
       "      <td>n</td>\n",
       "      <td>n</td>\n",
       "      <td>m</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>p</td>\n",
       "      <td>x</td>\n",
       "      <td>y</td>\n",
       "      <td>w</td>\n",
       "      <td>t</td>\n",
       "      <td>p</td>\n",
       "      <td>f</td>\n",
       "      <td>c</td>\n",
       "      <td>n</td>\n",
       "      <td>n</td>\n",
       "      <td>e</td>\n",
       "      <td>e</td>\n",
       "      <td>s</td>\n",
       "      <td>s</td>\n",
       "      <td>w</td>\n",
       "      <td>w</td>\n",
       "      <td>p</td>\n",
       "      <td>w</td>\n",
       "      <td>o</td>\n",
       "      <td>p</td>\n",
       "      <td>k</td>\n",
       "      <td>s</td>\n",
       "      <td>u</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>e</td>\n",
       "      <td>x</td>\n",
       "      <td>s</td>\n",
       "      <td>g</td>\n",
       "      <td>f</td>\n",
       "      <td>n</td>\n",
       "      <td>f</td>\n",
       "      <td>w</td>\n",
       "      <td>b</td>\n",
       "      <td>k</td>\n",
       "      <td>t</td>\n",
       "      <td>e</td>\n",
       "      <td>s</td>\n",
       "      <td>s</td>\n",
       "      <td>w</td>\n",
       "      <td>w</td>\n",
       "      <td>p</td>\n",
       "      <td>w</td>\n",
       "      <td>o</td>\n",
       "      <td>e</td>\n",
       "      <td>n</td>\n",
       "      <td>a</td>\n",
       "      <td>g</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "  class cap-shape cap-surface cap-color bruises odor gill-attachment  \\\n",
       "0     p         x           s         n       t    p               f   \n",
       "1     e         x           s         y       t    a               f   \n",
       "2     e         b           s         w       t    l               f   \n",
       "3     p         x           y         w       t    p               f   \n",
       "4     e         x           s         g       f    n               f   \n",
       "\n",
       "  gill-spacing gill-size gill-color stalk-shape stalk-root  \\\n",
       "0            c         n          k           e          e   \n",
       "1            c         b          k           e          c   \n",
       "2            c         b          n           e          c   \n",
       "3            c         n          n           e          e   \n",
       "4            w         b          k           t          e   \n",
       "\n",
       "  stalk-surface-above-ring stalk-surface-below-ring stalk-color-above-ring  \\\n",
       "0                        s                        s                      w   \n",
       "1                        s                        s                      w   \n",
       "2                        s                        s                      w   \n",
       "3                        s                        s                      w   \n",
       "4                        s                        s                      w   \n",
       "\n",
       "  stalk-color-below-ring veil-type veil-color ring-number ring-type  \\\n",
       "0                      w         p          w           o         p   \n",
       "1                      w         p          w           o         p   \n",
       "2                      w         p          w           o         p   \n",
       "3                      w         p          w           o         p   \n",
       "4                      w         p          w           o         e   \n",
       "\n",
       "  spore-print-color population habitat  \n",
       "0                 k          s       u  \n",
       "1                 n          n       g  \n",
       "2                 n          n       m  \n",
       "3                 k          s       u  \n",
       "4                 n          a       g  "
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Viewing my data \n",
    "\n",
    "mushroom_df.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<class 'pandas.core.frame.DataFrame'>\n",
      "RangeIndex: 8124 entries, 0 to 8123\n",
      "Data columns (total 23 columns):\n",
      " #   Column                    Non-Null Count  Dtype \n",
      "---  ------                    --------------  ----- \n",
      " 0   class                     8124 non-null   object\n",
      " 1   cap-shape                 8124 non-null   object\n",
      " 2   cap-surface               8124 non-null   object\n",
      " 3   cap-color                 8124 non-null   object\n",
      " 4   bruises                   8124 non-null   object\n",
      " 5   odor                      8124 non-null   object\n",
      " 6   gill-attachment           8124 non-null   object\n",
      " 7   gill-spacing              8124 non-null   object\n",
      " 8   gill-size                 8124 non-null   object\n",
      " 9   gill-color                8124 non-null   object\n",
      " 10  stalk-shape               8124 non-null   object\n",
      " 11  stalk-root                8124 non-null   object\n",
      " 12  stalk-surface-above-ring  8124 non-null   object\n",
      " 13  stalk-surface-below-ring  8124 non-null   object\n",
      " 14  stalk-color-above-ring    8124 non-null   object\n",
      " 15  stalk-color-below-ring    8124 non-null   object\n",
      " 16  veil-type                 8124 non-null   object\n",
      " 17  veil-color                8124 non-null   object\n",
      " 18  ring-number               8124 non-null   object\n",
      " 19  ring-type                 8124 non-null   object\n",
      " 20  spore-print-color         8124 non-null   object\n",
      " 21  population                8124 non-null   object\n",
      " 22  habitat                   8124 non-null   object\n",
      "dtypes: object(23)\n",
      "memory usage: 1.4+ MB\n"
     ]
    }
   ],
   "source": [
    "#Viewing my data, understanding the different features and columns\n",
    "\n",
    "mushroom_df.info()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>class</th>\n",
       "      <th>cap-shape</th>\n",
       "      <th>cap-surface</th>\n",
       "      <th>cap-color</th>\n",
       "      <th>bruises</th>\n",
       "      <th>odor</th>\n",
       "      <th>gill-attachment</th>\n",
       "      <th>gill-spacing</th>\n",
       "      <th>gill-size</th>\n",
       "      <th>gill-color</th>\n",
       "      <th>stalk-shape</th>\n",
       "      <th>stalk-root</th>\n",
       "      <th>stalk-surface-above-ring</th>\n",
       "      <th>stalk-surface-below-ring</th>\n",
       "      <th>stalk-color-above-ring</th>\n",
       "      <th>stalk-color-below-ring</th>\n",
       "      <th>veil-type</th>\n",
       "      <th>veil-color</th>\n",
       "      <th>ring-number</th>\n",
       "      <th>ring-type</th>\n",
       "      <th>spore-print-color</th>\n",
       "      <th>population</th>\n",
       "      <th>habitat</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>count</th>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "      <td>8124</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>unique</th>\n",
       "      <td>2</td>\n",
       "      <td>6</td>\n",
       "      <td>4</td>\n",
       "      <td>10</td>\n",
       "      <td>2</td>\n",
       "      <td>9</td>\n",
       "      <td>2</td>\n",
       "      <td>2</td>\n",
       "      <td>2</td>\n",
       "      <td>12</td>\n",
       "      <td>2</td>\n",
       "      <td>5</td>\n",
       "      <td>4</td>\n",
       "      <td>4</td>\n",
       "      <td>9</td>\n",
       "      <td>9</td>\n",
       "      <td>1</td>\n",
       "      <td>4</td>\n",
       "      <td>3</td>\n",
       "      <td>5</td>\n",
       "      <td>9</td>\n",
       "      <td>6</td>\n",
       "      <td>7</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>top</th>\n",
       "      <td>e</td>\n",
       "      <td>x</td>\n",
       "      <td>y</td>\n",
       "      <td>n</td>\n",
       "      <td>f</td>\n",
       "      <td>n</td>\n",
       "      <td>f</td>\n",
       "      <td>c</td>\n",
       "      <td>b</td>\n",
       "      <td>b</td>\n",
       "      <td>t</td>\n",
       "      <td>b</td>\n",
       "      <td>s</td>\n",
       "      <td>s</td>\n",
       "      <td>w</td>\n",
       "      <td>w</td>\n",
       "      <td>p</td>\n",
       "      <td>w</td>\n",
       "      <td>o</td>\n",
       "      <td>p</td>\n",
       "      <td>w</td>\n",
       "      <td>v</td>\n",
       "      <td>d</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>freq</th>\n",
       "      <td>4208</td>\n",
       "      <td>3656</td>\n",
       "      <td>3244</td>\n",
       "      <td>2284</td>\n",
       "      <td>4748</td>\n",
       "      <td>3528</td>\n",
       "      <td>7914</td>\n",
       "      <td>6812</td>\n",
       "      <td>5612</td>\n",
       "      <td>1728</td>\n",
       "      <td>4608</td>\n",
       "      <td>3776</td>\n",
       "      <td>5176</td>\n",
       "      <td>4936</td>\n",
       "      <td>4464</td>\n",
       "      <td>4384</td>\n",
       "      <td>8124</td>\n",
       "      <td>7924</td>\n",
       "      <td>7488</td>\n",
       "      <td>3968</td>\n",
       "      <td>2388</td>\n",
       "      <td>4040</td>\n",
       "      <td>3148</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "       class cap-shape cap-surface cap-color bruises  odor gill-attachment  \\\n",
       "count   8124      8124        8124      8124    8124  8124            8124   \n",
       "unique     2         6           4        10       2     9               2   \n",
       "top        e         x           y         n       f     n               f   \n",
       "freq    4208      3656        3244      2284    4748  3528            7914   \n",
       "\n",
       "       gill-spacing gill-size gill-color stalk-shape stalk-root  \\\n",
       "count          8124      8124       8124        8124       8124   \n",
       "unique            2         2         12           2          5   \n",
       "top               c         b          b           t          b   \n",
       "freq           6812      5612       1728        4608       3776   \n",
       "\n",
       "       stalk-surface-above-ring stalk-surface-below-ring  \\\n",
       "count                      8124                     8124   \n",
       "unique                        4                        4   \n",
       "top                           s                        s   \n",
       "freq                       5176                     4936   \n",
       "\n",
       "       stalk-color-above-ring stalk-color-below-ring veil-type veil-color  \\\n",
       "count                    8124                   8124      8124       8124   \n",
       "unique                      9                      9         1          4   \n",
       "top                         w                      w         p          w   \n",
       "freq                     4464                   4384      8124       7924   \n",
       "\n",
       "       ring-number ring-type spore-print-color population habitat  \n",
       "count         8124      8124              8124       8124    8124  \n",
       "unique           3         5                 9          6       7  \n",
       "top              o         p                 w          v       d  \n",
       "freq          7488      3968              2388       4040    3148  "
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Still viewing my data to understand the diferent types of data recorded here\n",
    "\n",
    "mushroom_df.describe()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "e    4208\n",
       "p    3916\n",
       "Name: class, dtype: int64"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Viewing my data. This tells me how many mushrooms are classified as edible and how many are classified as poisonous\n",
    "\n",
    "mushroom_df['class'].value_counts()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Use the KNN algorithm to impute missing values in the dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Creating features dataframe. This includes all columns except stalk root\n",
    "\n",
    "features = mushroom_df[['class','cap-shape','cap-surface','cap-color','bruises','odor','gill-attachment',\n",
    "                       'gill-spacing','gill-size','gill-color','stalk-shape','stalk-surface-above-ring',\n",
    "                       'stalk-surface-below-ring','stalk-color-above-ring','stalk-color-below-ring','veil-type', \n",
    "                       'veil-color','ring-number','ring-type','spore-print-color','population','habitat']]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Creating response dataframe. This includes only the stalk root column that has missing values\n",
    "\n",
    "response = mushroom_df[['stalk-root']]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "#One-Hot-Encoding Feature data per the instructions of the project. This will turn the features into just numbers\n",
    "#so that the machine learning algorithms can understand them\n",
    "\n",
    "from sklearn.preprocessing import OneHotEncoder\n",
    "\n",
    "features_encode = OneHotEncoder(sparse = False)\n",
    "\n",
    "features = features_encode.fit_transform(features)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Here, I am creating a mask so that I can create training and testing sets based off of whether or not there is are \n",
    "#missing values. My mask will make a missing value be True, and a non-missing value False. Then I implement my mask\n",
    "\n",
    "mask = mushroom_df['stalk-root'] == '?'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Creating my training data using my mask from above. The 'false' means that I am only pulling non missing values,\n",
    "#since my mask made True = ?\n",
    "\n",
    "training = features[mask == False]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Creating my testing data using my mask from above. This pulls my missing values\n",
    "\n",
    "testing = response[mask]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "train_f = features[mask == False] #Training features with no missing values\n",
    "\n",
    "train_r = response[~mask] #Training responses where there are missing values\n",
    "\n",
    "test_f = features[mask] #Testing features where there are missing values\n",
    "\n",
    "test_r = response[mask] #Testing resposes which is our list of ?s. This will be used after prediction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/julianam/opt/anaconda3/lib/python3.8/site-packages/sklearn/utils/validation.py:72: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel().\n",
      "  return f(**kwargs)\n"
     ]
    }
   ],
   "source": [
    "#Label encoding the response data for training only. \n",
    "\n",
    "from sklearn import preprocessing\n",
    "\n",
    "label_encode = preprocessing.LabelEncoder()\n",
    "\n",
    "train_r = label_encode.fit_transform(train_r)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Implementing my KNN classifier model and fitting it with my training features and responses. In the last line, \n",
    "#I predict the missing values by passing it the test features. This will replace the original missing responses\n",
    "\n",
    "from sklearn.neighbors import KNeighborsClassifier\n",
    "\n",
    "#Default Settings\n",
    "imputer = KNeighborsClassifier(n_neighbors=5, weights='uniform', algorithm='auto', leaf_size=30,\n",
    "                               p=2, metric='minkowski', metric_params=None, n_jobs=None)\n",
    "\n",
    "imputer.fit(train_f, train_r)\n",
    "\n",
    "missing_values = imputer.predict(test_f)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array(['b', 'b', 'e', ..., 'e', 'b', 'e'], dtype=object)"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Create data structure (list) called missing_values that contains all of the imputed values \n",
    "\n",
    "missing_values = label_encode.inverse_transform(missing_values)\n",
    "missing_values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "<ipython-input-18-d1852d8ceb2d>:1: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  test_r['stalk-root'] = missing_values\n"
     ]
    }
   ],
   "source": [
    "#Replacing the ? mark list that is all missing values with my predicted values list from above\n",
    "\n",
    "test_r['stalk-root'] = missing_values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Here, I am inserting the predicted values into the original dataframe so I can move forward on this assignment \n",
    "#with a full dataset and no missing data\n",
    "\n",
    "mushroom_df[mask] = test_r"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Graded Concept Question #1: Would it still be possible to train the KNN model if you one-hot encoded the response data instead? Why or why not?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Yes, it would still be possible to train the KNN model if you one-hot encoded the response data instead of label encoding the response data because the response data is not ordinal. One-hot encoding the data would make it binary, either 0 or 1 depending on if it was a missing value or not. There is no assigned order with One-Hot encoding, ex: 1 < 2 < 3. The label encoding makes the data ordinal, so the computer interprets values as being ranked. Label encoding works well for storing the values with less space being used up. One-hot encoding can become difficult in terms of dimensionality so it is used in conjunction with PCA. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Creating my X and y data. X are all the features that predict the class. Y is class because that is what we are\n",
    "#aiming to predict (edible or poisonous)\n",
    "\n",
    "X = mushroom_df[['cap-shape','cap-surface','cap-color','bruises','odor','gill-attachment',\n",
    "                       'gill-spacing','gill-size','gill-color','stalk-shape','stalk-root','stalk-surface-above-ring',\n",
    "                       'stalk-surface-below-ring','stalk-color-above-ring','stalk-color-below-ring','veil-type', \n",
    "                       'veil-color','ring-number','ring-type','spore-print-color','population','habitat']]\n",
    "\n",
    "y = mushroom_df[['class']]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "#One hot encode X as per instructions (feautres)\n",
    "\n",
    "OH_encoder = OneHotEncoder(sparse = False)\n",
    "\n",
    "X = OH_encoder.fit_transform(X)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Label encode y as per instructions (responses)\n",
    "\n",
    "label_encoder = preprocessing.LabelEncoder()\n",
    "\n",
    "y = y.ravel()\n",
    "\n",
    "y = label_encoder.fit_transform(y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Using good 'ole train-test split by sklearn to do a random split of the data and create training sets and testing\n",
    "#sets. The testing sets will be used to see the accuracy of our models. \n",
    "\n",
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 42)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Train a RandomForestClassifier as well as a LogisticRegression model to predict whether a mushroom is edible or poisonous given this data set of nominally-valued characteristics."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 2 µs, sys: 0 ns, total: 2 µs\n",
      "Wall time: 4.77 µs\n"
     ]
    }
   ],
   "source": [
    "#Instatiating an object of the RandomForestclassifier class and training it on the training data\n",
    "\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "\n",
    "rft_clf = RandomForestClassifier(random_state = 42)\n",
    "\n",
    "rft_clf.fit(X_train,y_train)\n",
    "\n",
    "%time"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 5 µs, sys: 0 ns, total: 5 µs\n",
      "Wall time: 5.01 µs\n"
     ]
    }
   ],
   "source": [
    "#Instatiating an object of the LogisticRegression class and training it on the training data\n",
    "\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "\n",
    "log_reg = LogisticRegression(random_state = 42)\n",
    "\n",
    "log_reg.fit(X_train, y_train)\n",
    "\n",
    "%time"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Graded Concept Question #2: Would it still be possible to train these two models if you one-hot encoded the response data instead, being careful to specify that the drop parameter of the OneHotEncoder class is set to ‘first’? Why or why not?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Yes, you would be able to one hot encode the response data instead of label encoding the response data because the response data does not have an order to it. It is either edible or poisonous. One is not worth more than the other."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Computing the accuracy, precision, and recall scores for a test set on both the RandomForestClassifer model and the Logistic Regression model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Random Forest Accuracy = 1.0\n",
      "Random Forest Precision = 1.0\n",
      "andom Forest Recall = 1.0\n",
      "Logistic Regression Accuracy = 1.0\n",
      "Logistic Regression Precision = 1.0\n",
      "Logistic Regression Recall = 1.0\n"
     ]
    }
   ],
   "source": [
    "from sklearn.metrics import accuracy_score\n",
    "from sklearn.metrics import precision_score\n",
    "from sklearn.metrics import recall_score\n",
    "\n",
    "\n",
    "rft_predict = rft_clf.predict(X_test)\n",
    "log_predict = log_reg.predict(X_test)\n",
    "\n",
    "#RandomForestClassifier\n",
    "rft_acc_score = accuracy_score(y_test, rft_predict)\n",
    "rft_prec_score = precision_score(y_test, rft_predict, average = 'micro') \n",
    "rft_recall_score = recall_score(y_test, rft_predict, average = 'micro')\n",
    "\n",
    "print('Random Forest Accuracy = %s' % (rft_acc_score))\n",
    "print('Random Forest Precision = %s' % (rft_prec_score))\n",
    "print('andom Forest Recall = %s' % (rft_recall_score))\n",
    "\n",
    "\n",
    "#LogisticRegression\n",
    "log_acc_score = accuracy_score(y_test, log_predict)\n",
    "log_prec_score = precision_score(y_test, log_predict, average = 'micro') \n",
    "log_recall_score = recall_score(y_test, log_predict, average = 'micro')\n",
    "\n",
    "print('Logistic Regression Accuracy = %s' % (log_acc_score))\n",
    "print('Logistic Regression Precision = %s' % (log_prec_score))\n",
    "print('Logistic Regression Recall = %s' % (log_recall_score))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Quick Analysis"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "With the data we were provided, overfitting is clear here. We can see this through the accuracy scores for both the Random Forest Classifier and the Logistic Regression models. An accuracy score of 1 is not normal and is not what we want to see because the model is too good at predicting data it has seen before and will struggle to predict data it has not seen before. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Performing dimensionality reduction using PCA and keep 95% of the variance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Original number of dimensions:  146\n",
      "Number of dimensions after PCA:  29\n",
      "Percentage that I was able to reduce dimensions by:  80.14 %\n"
     ]
    }
   ],
   "source": [
    "from sklearn.decomposition import PCA\n",
    "\n",
    "#Here, I am performing dimensionality reduction using PCA and I am specifying in the n_components parameter that\n",
    "#I want to keep 95% of the variance as specified in the project instructions. I can do this by using a float number\n",
    "#between 0.0 and 1.0. \n",
    "\n",
    "pca = PCA(n_components=0.95)\n",
    "X_reduced = pca.fit_transform(X)\n",
    "\n",
    "#Here, I am printing out the original number of dimensions in our X dataframe. Then I print out the number of\n",
    "#dimensions after performing dimensionality reduction. Lastly, I print out the percent that I was able to reduce\n",
    "#the number of dimensions by \n",
    "\n",
    "full_dims = X.shape[1]\n",
    "reduced_dims = X_reduced.shape[1]\n",
    "\n",
    "print('Original number of dimensions: ',full_dims)\n",
    "print('Number of dimensions after PCA: ',reduced_dims)\n",
    "print('Percentage that I was able to reduce dimensions by: ',round((full_dims-reduced_dims)/full_dims*100,2),'%')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Training two new models, a RandomForestClassifier and a LogisticRegression model, on the reduced dataset to predict whether a mushroom is edible or not."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Doing a new train test split using the reduced data\n",
    "\n",
    "X_train_reduced, X_test_reduced, y_train, y_test = train_test_split(X_reduced, y, test_size=0.20, random_state=42)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 2 µs, sys: 0 ns, total: 2 µs\n",
      "Wall time: 3.81 µs\n"
     ]
    }
   ],
   "source": [
    "from sklearn.ensemble import RandomForestClassifier\n",
    "\n",
    "rft_clf_reduced = RandomForestClassifier(random_state = 42)\n",
    "\n",
    "rft_clf_reduced.fit(X_train_reduced,y_train)\n",
    "\n",
    "%time"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 4 µs, sys: 1e+03 ns, total: 5 µs\n",
      "Wall time: 4.05 µs\n"
     ]
    }
   ],
   "source": [
    "from sklearn.linear_model import LogisticRegression\n",
    "\n",
    "log_reg_reduced = LogisticRegression()\n",
    "\n",
    "log_reg_reduced.fit(X_train_reduced, y_train)\n",
    "\n",
    "%time"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Computing the accuracy, precision, and recall scores for the model trained on the reduced data set using the same test set as before."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Making my predictions on my newly trained reduced models\n",
    "\n",
    "rft_red_predict = rft_clf_reduced.predict(X_test_reduced)\n",
    "log_red_predict = log_reg_reduced.predict(X_test_reduced)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Reduced Random Forect Classifier Accuracy = 1.0\n",
      "Reduced Random Forect Classifier Precision = 1.0\n",
      "Reduced Random Forect Classifier Recall = 1.0\n",
      "Reduced Logistic Regression Accuracy = 0.9987692307692307\n",
      "Reduced Logistic Regression Precision = 0.9987692307692307\n",
      "Reduced Logistic Regression Recall = 0.9987692307692307\n"
     ]
    }
   ],
   "source": [
    "#RandomForestClassifier Accuracy, Precision, and Recall Scores\n",
    "\n",
    "rft_reduced_acc_score = accuracy_score(y_test, rft_red_predict)\n",
    "rft_reduced_prec_score = precision_score(y_test, rft_red_predict, average = 'micro') \n",
    "rft_reduced_recall_score = recall_score(y_test, rft_red_predict, average = 'micro')\n",
    "\n",
    "print('Reduced Random Forect Classifier Accuracy = %s' % (rft_reduced_acc_score))\n",
    "print('Reduced Random Forect Classifier Precision = %s' % (rft_reduced_prec_score))\n",
    "print('Reduced Random Forect Classifier Recall = %s' % (rft_reduced_recall_score))\n",
    "\n",
    "\n",
    "#LogisticRegression Accuracy, Precision, and Recall Scores\n",
    "\n",
    "log_reduced_acc_score = accuracy_score(y_test, log_red_predict)\n",
    "log_reduced_prec_score = precision_score(y_test, log_red_predict, average = 'micro') \n",
    "log_reduced_recall_score = recall_score(y_test, log_red_predict, average = 'micro')\n",
    "\n",
    "print('Reduced Logistic Regression Accuracy = %s' % (log_reduced_acc_score))\n",
    "print('Reduced Logistic Regression Precision = %s' % (log_reduced_prec_score))\n",
    "print('Reduced Logistic Regression Recall = %s' % (log_reduced_recall_score))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Tabulating the model information"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Models              | Item      | Full Data | PCA Reduced |\n",
    "|------------------:|:---------:|:----------|:------------|\n",
    "|Random Forest      |Accuracy   | 1.0       | 1.0         |\n",
    "|    -              | Precision | 1.0       | 1.0         |\n",
    "|    -              | Recall    | 1.0       | 1.0         |\n",
    "|    -              | Time      |2 µs       | 2 µs        |\n",
    "|Logistic Regression| Accuracy  | 1.0       | 0.9987      |\n",
    "|    -              | Precision | 1.0       | 0.9987      |\n",
    "|    -              | Recall    | 1.0       | 0.9987      |\n",
    "|    -              | Time      |5 µs       | 5 µs        |"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Conclusions can you make about these models and the PCA process? How do the models compare? Discuss the trends observed for model training time and performance for the full and reduced data sets."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The PCA process reduced the dimensionality of the data and improved the accuracy, precision, and recall scores for the Logistic Regression model. It did not improve the scores for my Random Forest model. Therefore, PCA improved the performance of the models when compared to the full data set."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
